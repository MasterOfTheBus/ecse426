#include <stdio.h>
#include "stm32f4xx.h"                  // Device header
#include "stm32f4xx_conf.h"
#include "UI.h"


/**
	*	@brief Hardware Timer
	*	
	*	- Control 7-segment multiplexing operations 
	*	- Delay generated by TIM3
	*	- Use specific bus clock (RCC driver): TimerClockingFrequency / (Period x prescalar) = desired rate
	*/	
	
int timerValue;	

void Timer_config(uint16_t Prescaler,
									uint16_t CounterMode,
									uint32_t Period,
									uint16_t ClockDivision,
									uint8_t RepetitionCounter){
	//Enable Timer3									
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
										
	//Timer configuration
	TIM_TimeBaseInitTypeDef timer_init;
	timer_init.TIM_Prescaler = Prescaler;
	timer_init.TIM_CounterMode = CounterMode;
	timer_init.TIM_Period = Period;
	timer_init.TIM_ClockDivision = ClockDivision;
	timer_init.TIM_RepetitionCounter = RepetitionCounter;
	
	TIM_TimeBaseInit(TIM3, &timer_init);
	TIM_Cmd(TIM3, ENABLE);
}
	

void configInit_GPIO(GPIO_TypeDef* GPIOx,
										 uint32_t periph_GPIOx,
										 uint32_t pins,
										 GPIOMode_TypeDef mode,
										 GPIOSpeed_TypeDef speed,
										 GPIOOType_TypeDef oType,
										 GPIOPuPd_TypeDef puPd){
	//Enable GPIO clock
	RCC_AHB1PeriphClockCmd(periph_GPIOx, ENABLE);
	
	//GPIO configuration
	GPIO_InitTypeDef gpio;
	gpio.GPIO_Pin = pins;
	gpio.GPIO_Mode = mode;
	gpio.GPIO_Speed = speed;
	gpio.GPIO_OType = oType;
	gpio.GPIO_PuPd = puPd;
	
	GPIO_Init(GPIOx, &gpio);
										 
											 
}

void Keypad_read(){

	
	
}


void Display(){
	// Get hardware timer value
	timerValue = TIM_GetCounter(TIM3);

	if (timerValue < 200){
		GPIO_WriteBit(GPIOE, GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_10 | GPIO_Pin_12 | GPIO_Pin_14, Bit_RESET);
		GPIO_WriteBit(GPIOD, GPIO_Pin_9, Bit_RESET);
		GPIO_WriteBit(GPIOE, GPIO_Pin_9 | GPIO_Pin_11 | GPIO_Pin_13 , Bit_SET);
		GPIO_WriteBit(GPIOB, GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15, Bit_SET);
		GPIO_WriteBit(GPIOD, GPIO_Pin_8 | GPIO_Pin_10 , Bit_SET);
		
	} else if (timerValue >= 200){
    GPIO_WriteBit(GPIOE, GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_10 | GPIO_Pin_12 | GPIO_Pin_14, Bit_RESET);
		GPIO_WriteBit(GPIOD,  GPIO_Pin_9, Bit_RESET);
		GPIO_WriteBit(GPIOE, GPIO_Pin_9 | GPIO_Pin_11 | GPIO_Pin_13 , Bit_RESET);
		GPIO_WriteBit(GPIOB, GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15, Bit_RESET);
		GPIO_WriteBit(GPIOD, GPIO_Pin_8 | GPIO_Pin_10 , Bit_RESET);
	}
	
	return;
}



/**
	*	@brief Initialize user interface using GPIO
	*	
	*	- Read user input from keypad	(pins LEFT TO RIGHT)
	*																PE6(brown)	PC13(red)	PE4(orange)		PE5(yellow)	PB4(green)		PB5(blue)		PD1(purple)	PD2(black)
	*	- Translate numbers to be displayed into control signals
	*	- Send signals out through 7-segment display (pins from LEFT TO RIGHT)
	*																PB11(black)	PB12(purple)	PB13(blue)	PB14(green)	PB15(yellow)	PD8(orange)		PD9(red)	PD10(brown)
	*																PE7(black)	PE8(purple)		PE9(blue)		PE10(green)	PE11(yellow)	PE12(orange)	PE13(red)	PE14(brown)															
	*
	*	Must add the pin layout~
	*/
