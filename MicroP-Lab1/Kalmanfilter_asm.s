	AREA text, CODE, READONLY
		EXPORT Kalmanfilter_asm
			
Kalmanfilter_asm
		
	; initialize q (S1), r(S2) and p(S3) to 0.1	
	VMOV.F32 S1, #10
	VMOV.F32 S2, #1
	VDIV.F32 S1, S2, S1 ; TO GET 0.1, TRY LOAD FROM MEMORY, ADD, SUBT, DIV...
	
	VMOV.F32 S2, S1
	VMOV.F32 S3, S1

	; initialize k (S4) and x (S5) to 0.
	VSUB.F32 S4, S1, S2
	VMOV.F32 S5, S4
; FOR TESTING ONLY, WRITE VALUES TO MEMORY	
	MOV R3, #0
	
	VSTR S1, [R3]
	VSTR S2, [R3{, #4}]
	VSTR S3, [R3{, #8}]
	VSTR S4, [R3{, #12}]
	
	; LOAD KALMAN FILTER STATE FROM MEMORY USING POINTER R3
	VLDR S1, [R3]
	VLDR S2, [R3{, #4}]
	VLDR S3, [R3{, #8}]
	VLDR S4, [R3{, #12}]
	
	MOV R2, #3			; ARRAY LENGTH, FOR TESTING ONLY~ 
	MOV	R4, #1			; INITIALIZE COUNTER TO 1
	
	; CREATING AN ARRAY OF INPUTS
	VMOV.F32 S9, #1
	VMOV.F32 S10, #10
	VMOV.F32 S11, #15
	VMOV.F32 S12, #1
	VMOV.F32 S13, #1
	VPUSH {S9-S13}	; update R13 (SP)
	
	; update
UPDATE	VPOP {S0}	; CONTAINS THE FIRST INPUT
		VADD.F32 S3, S3, S1
		VADD.F32 S5, S3, S1 ;P+R
		VDIV.F32 S4, S3, S5
		VSUB.F32 S6, S0, S5
		VMUL.F32 S7, S4, S6
		VADD.F32 S5, S5, S7
		VNEG.F32 S8, S4
		VADD.F32 S8, S8, S4
		VMUL.F32 S3, S8, S3
		ADD R4, #1	; INCREMENT COUNTER
		CMP R4, R2	; COMPARE ARRAY LENGTH VS COUNTER
		BLE UPDATE	; ARRAY LENGTH IS HIGHER THAN THE COUNTER, LOOP AGAIN
		
	
	BX	LR;

	END